%YAML 1.1
---
id: 0af76d5
title: A race condition in message filter of TF2
description: >
    "In ROS Message filters are a tool that allows registering subscribers that work with multiple msgs, or trigger callbacks if an arriving message satisfies a predicate. TF provides message filters that are specificlaly tailored---they register callbacks that can triggered whenever the incoming message can be transformed (using tf.transform(..)) into a set of coordinate frames. For instance one can trigger a callback on messages of certain type (a point cloud or an object with a spatial dimension) that can be transformed to selected frames.
    The problem is that the checking by tf msg filters whether that is possible and the invocation of the callback happen at two separate times, so even if the check succeeds, by the time the callback is fired, it could fail, because the frames could already have been pushed out of the tf buffer.
    The callbel needs to retrieve the transforms. If tf.lookupTransform(...)  is used it mail fail, even if the transform was applicable at the time of the predicate checking.
    The race condition is built-in into the design of the API. You can only experience it when you start to use the API, and don't take additional (awkward) protection measures.  This is best summarized with the quote from the original bug report: ''tf::message_filters are difficult to use because you're only guaranteed to have a transform at the beginning of the callback, not when you actually want to use the transform. (..) you can deal with this through judicious use of try-catch loops and setTolerance(), but that seems hacky. Multiple users have had trouble with this concept.''
    To the best of our knowledge, this bug / design issue remains in ROS til the time of writing this analysis. It has never been addressed."
classification: "CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')"
keywords: ['c++', 'race condition', 'callback']
system: core component
severity: error
links:
  - "https://github.com/ros/geometry2/blob/5722773de7d688bcaf8dfe68a0f2a55ff49dc9d3/tf2_ros/include/tf2_ros/message_filter.h The file where the message filter is implemented."
  - "https://github.com/ros/geometry2/blob/5722773de7d688bcaf8dfe68a0f2a55ff49dc9d3/tf2_ros/include/tf2_ros/message_filter.h#L88 fragment of the file with the API doc for the message filter."
  - "https://github.com/ros/geometry2/blob/5722773de7d688bcaf8dfe68a0f2a55ff49dc9d3/tf2_ros/include/tf2_ros/message_filter.h#L293 the method invoked on the new (incoming) message."
bug:
  phase: runtime-operation
  specificity: general issue
  architectural-location: platform code
  applicatios: null
  task: null
  subsystem: generic task component
  package: ros/geometry2/tf2_ros
  languages:
    - C++
  detected-by: null
  reported-by: member developer
  issue: https://github.com/ros/geometry2/issues/35
  time-reported: 2013-10-29T01:05:05Z
  reproducibility: sometimes
  trace:
  reproduction: >
    The idea is to create a buffer object, manually insert some transforms into it, then instantiate a tf message filter, invoke its callbacks do some trickery with a manually crafted msg (its header) and then show that the transform we're looking for, and which msg filters said was there, is no longer there.
    There is no fixing commit and fixing this requires a redesign of the component (to our best knowledge this race condition has not been fixed until today).  In the discussions whether a design flaw is a bug, we decided to reproduce the race, but not fix the design.  Thus this bug has no fixing commit.
fix:
  repo: https://github.com/ros/geometry2
  hash: null
  pull-request: null
  license: []
  fix-in: []
  languages:
    - C++
  time: null
time-machine:
  ros_distro: hydro
  ros_pkgs:
    - tf2_ros
  datetime: 2013-10-29T01:05:05Z
